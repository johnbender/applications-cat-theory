<!DOCTYPE HTML>
<html>
  <head>
    <link rel="stylesheet" href="css/bootstrap.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="css/font-awesome.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="css/poster.css" type="text/css" media="screen" />
    <script type="text/javascript" src="prettify.js"></script>
  </head>
  <body onload="prettyPrint()">
    <div id="title">
      <h1>Automatically Suggesting Performance Optimizations in jQuery Based JavaScript Applications</h1>
    </div>
    <div id="content">
      <div id="left">
        <div class="row-fluid">
          <h2 class="span12">The Chains That Bind</h2>
        </div>
        <div class="row-fluid border-right">
          <div id="jquery-piechart" class="span4">
	          <div class="figure img-figure">Figure 1</div>
	          <img src="img/top-10k-bar.png" style="float: right; margin-top: 60px"/>
          </div>
          <div id="piechart-caption" class="span8 text-block">
            <h3><span class="icon-th"></span>Ubiquity Thy Name is jQuery</h3><p>jQuery is an extremely popular open source JavaScript library, dual licensed under the GPL and MIT licenses. Figure 1 shows the percentage use of jQuery among the top ten thousand, hundred thousand, and one millions websites on the internet as ranked by Alexa [!!]. Additionally the project's website sees more than one hundred thousand [!!] unique visits a month from developers all over the world. Given these numbers it's fair to say that jQuery is one of the most popular libraries available to JavaScript developers, and possibly one of the most popular open source libraries available to any developer.</p>

<p>This popularity is due in part to the fluent interface that the library promotes for manipulating the browser's document object model. As with many abstractions that simplify complex data manipulation it often requires performance tradeoffs. Here we identify a subset of chainable jQuery methods that can be fused in the interest of increasing performance. As a result we derive a simple jQuery extension that can assist developers in identifying when these methods are being used.</p>
          </div>
        </div>
        <div class="row-fluid" style="display: none">
          <div class="span12">
            <pre class="large prettyprint linenums">
jQuery( <span class="string">"div"</span> ).hide().addClass( <span class="string">"foo"</span> ).show();</pre>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="explain-chaining" class="span4 text-block">
	    <h3><span class="icon-user"></span>Fluent Interface</h3><p>In Figure 2 you can see an example of a typical DOM manipulation built using jQuery's chainable methods. In this case all the <code>HTMLDivElement</code>s are selected from the DOM, hidden, the <code>foo</code> CSS class is added, and they are shown again. Figure 3 shows a "deabstracted" naive implementation of the method chain from Figure 2, and, as you can see, iterating over the set three times where one would seemingly suffice suggests an opportunity for a performance improvement.</p>

<p>Internally these methods are implemented using for loops or in one of two forms supported by the library, the map form with <code>jQuery.map</code> and the each form with <code>jQuery.each</code>.</p>
          </div>
          <div id="for-loops" class="span8">
            <pre class="prettyprint linenums stack">jQuery( <span class="string">"div"</span> ).hide().addClass( <span class="string">"foo"</span> ).show();<div class="figure">Figure 2</div></pre>

            <pre class="prettyprint linenums">
<span class="keyword">var</span> <span class="variable-name">$divs</span> = $( <span class="string">"div"</span> );

<span class="keyword">for</span>( <span class="keyword">var</span> <span class="variable-name">i</span> = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"style"</span>, <span class="string">"display: none;"</span> );
}

<span class="keyword">for</span>( i = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"class"</span>, <span class="string">"foo"</span> );
}

<span class="keyword">for</span>( i = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"style"</span>, <span class="string">"display: block;"</span> );
}<div class="figure">Figure 3</div>
</pre>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="map-form-content" class="span6">
            <div class="text-block">
              <h3><span class="icon-share"></span>Map Form</h3>
              <p>One of the two general forms that jQuery methods take is referred to here as the "map form". This leverages the jQuery helper methods <code>jQuery.map</code> or <code>jQuery.fn.map</code> to alter each element in the jQuery object set. This is the form with which our work is predominantly concerned due to the way it promotes operations on elements without side effects.</p>
            </div>
          </div>
          <div id="each-form-content" class="span6">
            <div class="text-block">
              <h3><span class="icon-edit"></span>Each Form</h3>
              <p>The second of the two forms that one might find underlying jQuery methods is the "each form". Here side effects are the order of the day as there is no expectation that the element provided to the callback will be returned, Figure 5. The standard and optimizations described here can also be applied with this form because of JavaScript's pass by reference nature where objects are concerned. Unfortunately composition becomes impossible and the category definitions will not apply in those cases.</p>
            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div id="map-form" class="span6">
            <pre class="prettyprint linenums">
$.map( <span class="builtin">this</span>, <span class="keyword">function</span>( <span class="js2-function-param">elem</span>, <span class="js2-function-param">i</span> ){
  <span class="comment">// manipulate HTMLElement
</span>  <span class="keyword">return</span> elem;
});<div class="figure">Figure 4</div>
</pre>
          </div>
          <div id="each-form" class="span6">
            <pre class="prettyprint linenums">
$.each( <span class="builtin">this</span>, <span class="keyword">function</span>( <span class="js2-function-param">elem</span>, <span class="js2-function-param">i</span> ){
  <span class="comment">// manipulate HTMLElement
</span>});
<div class="figure">Figure 5</div>
</pre>
          </div>
        </div>
        <div class="row-fluid">
          <div class="text-block span6">
            <h3>When to Optimize?</h3>
            <p>Given that many of jQuery's core methods and the thriving plugin ecosystem that accompanies them leverage these forms [!! - possible list them in a figure] there is likely great value in identifying ways to reduce the full number of set itterations made when they are used in chains. Unfortunately the source that makes up these methods is often complex even from the implementors perspective so a rigorous definition of which can be targetted for optimization has value. For that purpose we turn to some rudimentary category theory.</p>
          </div>
          <div class="text-block span6">
            <h3>jQuery Itterative Methods</h3> TODO show some percentage of the jQuery api that is itterative. Pie chart?
          </div>
        </div>
      </div>
      <div id="middle">
        <div class="row-fluid">
          <h2 class="span12">Categorically Identifiable</h2>
        </div>
        <div class="row-fluid border-right">
          <div id="html" class="span6 text-block">
            <img src="img/html5-logo-512.png" id="html-logo"></img>
            <h3><span class="icon-check"></span>Defining Html</h3>
            <div class="category-preamble">
              <p>The Category <strong>Html</strong> is extremely simple. The objects in <strong>Html</strong> are the HTMLElements that the reader may be familiar with from the JavaScript DOM API (eg, HTMLAnchorElement). The morphisms are JavaScript functions from HTMLElements to to HTMLElements. Next we verify that <strong>Html</strong> satisfies the three category laws: identity, composition, and closure under composition (Figures 6,7,8).</p>
            </div>
            <div class="row-fluid">
              <div class="span6">
                <pre class="prettyprint linenums small">
<span class="keyword">function</span> <span class="function-name">id</span>( <span class="js2-function-param">a</span> ) {
  <span class="keyword">return</span> a;
}

<div class="figure">Figure 6</div></pre>
              </div>
              <div class="span6">
                <pre class="prettyprint linenums small">
<span class="keyword">function</span> <span class="function-name">compose</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>( <span class="js2-function-param">a</span> ) {
    <span class="keyword">return</span> f(g(a));
  };
}<div class="figure">Figure 7</div></pre>
              </div>
            </div>

            <p style="min-height: 2.6in">The identity function is trivial and function composition is always associative. We know that the morphisms in <strong>Html</strong> are closed under composition because the functions accept as their only argument HTMLElements and return only HTMLElements. Having met the three requirements for a category with <strong>Html</strong> we can move on to the second, and more complex category <strong>Jqry</strong>.</p>

            <pre class="prettyprint linenums stack">
<span class="keyword">function</span> <span class="function-name">a</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"foo"</span>, <span class="string">"bar"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">function</span> <span class="function-name">b</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"baz"</span>, <span class="string">"bak"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">var</span> <span class="variable-name">elem</span> = document.getElementById( <span class="string">"bing"</span> );
elem.getAttribute( <span class="string">"foo"</span> ); <span class="comment">// undefined
</span>elem.getAttribute( <span class="string">"baz"</span> ); <span class="comment">// undefined
</span>
elem = compose( a, b )( elem );
elem.getAttribute( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span>elem.getAttribute( <span class="string">"baz"</span> ); <span class="comment">// "bak"</span>
<div class="figure">Figure 8</div></pre>

            <p>Notice the use of <code>a</code> and <code>b</code> from the <strong>Html</strong> <code>compose</code> example in Figure 8 for the functions that are mapped using <code>$.map</code> over the set of elements in the jQuery objects in Figure 11. This plays an important roll in understanding the Functor from <strong>Html</strong> to <strong>Jqry</strong>.</p>
          </div>
          <div id="jqry" class="span6 text-block">
            <img src="img/jquery-logo-320.png" id="jqry-logo"></img>
            <h3><span class="icon-check"></span>Defining Jqry</h3>
            <div class="category-preamble">
              <p><strong>Jqry</strong> is the category of <code>jQuery</code> objects and functions from <code>jQuery</code> objects to <code>jQuery</code> objects. It&#8217;s only slightly more complex than <strong>Html</strong> because the reader must accept <code>this</code> as an implicit parameter to the JavaScript functions that are the category&#8217;s morphisms. Also, these morphisms must be defined on the <code>$.fn</code> object to guarantee the value of <code>this</code> is a <code>jQuery</code> object.</p>
            </div>

            <div class="row-fluid">
              <div class="span6">
            <pre class="prettyprint linenums small">
<span class="js2-external-variable">$</span>.fn.<span class="function-name">id</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>;
};

<div class="figure">Figure 9</div>
</pre>
              </div>
              <div class="span6">
            <pre class="prettyprint linenums small">
<span class="js2-external-variable">$</span>.<span class="function-name">compose</span> = <span class="keyword">function</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> f.apply(g.apply(<span class="builtin">this</span>))
  };
};<div class="figure">Figure 10</div></pre>

              </div>
            </div>
            <p style="min-height: 2.6in">The value of <code>this</code>, and the constraint that the morphisms must be defined on <code>$.fn</code>, plays an important role in the way that the functions behave in the <strong>Jqry</strong> category. The prototype of all jQuery objects is <code>$.fn</code>, meaning when you call <code>$("div").foo()</code> it finds <code>foo</code> on the <code>$.fn</code> by following the prototype chain.</p>

            <pre class="prettyprint linenums stack">
<span class="js2-external-variable">$</span>.fn.<span class="function-name">a</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> $.map( <span class="builtin">this</span>, a );      <span class="comment">// a from figure 8
</span>};

<span class="js2-external-variable">$</span>.fn.<span class="function-name">b</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> $.map( <span class="builtin">this</span>, b );      <span class="comment">// b from figure 8
</span>};

<span class="keyword">var</span> <span class="variable-name">$elem</span> = $( <span class="string">"#example-anchor"</span> );
$elem.attr( <span class="string">"foo"</span> );            <span class="comment">// undefined
</span>$elem.attr( <span class="string">"baz"</span> );            <span class="comment">// undefined
</span><span class="js2-external-variable">$</span>.fn.aAndB = $.compose( $.fn.a, $.fn.b );

$elem.aAndB().attr( <span class="string">"foo"</span> );    <span class="comment">// "bar"
</span>$elem.attr( <span class="string">"baz"</span> );            <span class="comment">// "bak></span>
<div class="figure">Figure 11</div></pre></pre>
            <p>Defining composition is a bit more complex for <strong>Jqry</strong> than it is for <strong>Html</strong> if only because forcing the value that <code>this</code> will represent in the composed functions takes more work than just passing in the values as parameters. The first function, <code>g</code>, in Figure 10 is invoked by forwarding the arguments and explicitly defining its <code>this</code> value using the <code>apply</code> method common to all JavaScript functions. The return value is a jQuery object which becomes <code>this</code> in the application of <code>f</code>. As a result, we know that the morphisms of <strong>Jqry</strong> are closed under composition because each accepts and returns only jQuery objects.</p>

          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="functor" class="span12 text-block">
            <h3><span class="icon-check"></span>Defining a Functor</h3>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="functor-law-fusion" class="span12 text-block">
            <h3><span class="icon-random"></span>Fuse with Confidence</h3>
          </div>
        </div>
      </div>
      <div id="right">
        <div class="row-fluid">
          <h2 class="span12">Automatically <span class="label label-warning">Warning</span> the User</h2>
        </div>
      </div>
    </div>
  </body>
</html>
