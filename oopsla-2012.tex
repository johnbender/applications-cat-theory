%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{OOPSLA 2012}{October 19--26, Tucson, AZ}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

% These are ignored unless
% 'preprint' option specified.
\preprintfooter{Identifying jQuery Performance Optimizations}

\title{Automatically Identifying Performance Optimizations for jQuery Based JavaScript Applications}

\authorinfo{John Bender}
           {}
           {john.m.bender@gmail.com}
\maketitle

\begin{abstract}
The jQuery JavaScript library makes the manipulation of the Document Object Model easy and intuitive via chained method calls, but an unfortunate side effect of its fluent interface is that an unwary programmer can easily introduce unnecessary performance overhead. Though desktop browsers have become fast enough to hide much of the problem, the growing complexity of HTML documents and the ubiquity of alternative environments in which JavaScript is now running have returned performance to a place of importance. Using category theory we define a set of JavaScript functions and jQuery methods that can be optimized using loop fusion. In addition, we derive a library to help developers quickly identify opportunities to make these optimizations. As a result the developer can spend less time focusing on performance and more time on adding features and value to his or her applications.
\end{abstract}

\category{D.2.7}{Distribution, Maintenance, and Enhancement}{Enhancement}
\category{D.2.2}{Design Tools and Techniques}{Software libraries}

\terms
Performance, Design

\keywords
JavaScript, Category Theory, Loop Fusion, Optimization

\section{Introduction}

JavaScript that leverages the jQuery library can often be identified by its fluency. That is, users are encouraged to make alterations to jQuery objects by ``chaining'' methods [1]. Furthermore jQuery extension authors are counciled to always return the altered jQuery object to facilitate this form of serial method invocation [2]. A simple example will illustrate:

\begin{verbatim}
jQuery( 'div' ).hide().addClass( 'foo' ).show();
\end{verbatim}

Here, all HTMLDivElements in the document are retrieved, hidden, altered to add an additional CSS class, and then shown again. Each method, hide, addClass, and show alters all the elements in the jQuery object-set and then provides them for the next method to do the same.

In many cases these method definitions take one of two forms. The first, hereafter referred to as the map-form, uses the built in jQuery method \verb|map| to apply a JavaScript function to each HTMLElement in a given jQuery object-set.

\begin{verbatim}
jQuery.fn.mapForm = function(){
  return this.map(function( htmlElement ) {
    // some alteration to the html element
    return htmlElement;
  });
};
\end{verbatim}

The invocation of \verb|map| on \verb|this| takes a function argument, here a closure, and passes in each HTMLElement of the jQuery object-set for it to manipulate and replace. As with all methods defined on \verb|jQuery.fn|, \verb|this| represents an instance of that jQuery object-set. Upon successful iteration over the whole set of elements the result is returned for any subsequent method calls in a chain. The second form, which we won't cover here but bears mentioning, is similar but substitutes \verb|each| [3] for \verb|map|.

If n methods of this form are invoked in sequence it means means n iterations over the entirety of the object-set. It appears as though the act of organizing the API into chainable methods, while seemingly easy to read and maintain can introduce unecessary overhead into applications built in this fashion. Here, we hope to aid developers in reducing the number of full iterations while maintaining the appealing fluent interface:


\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[loop fusion]{smith02}
\bibitem[category theory]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
