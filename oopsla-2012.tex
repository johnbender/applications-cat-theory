%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint,10pt]{sigplanconf}
\nocaptionrule

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{OOPSLA 2012}{October 19--26, Tucson, AZ}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

% These are ignored unless
% 'preprint' option specified.
\preprintfooter{Identifying jQuery Performance Optimizations}

\title{Automatically Identifying Performance Optimizations for jQuery Based JavaScript}

\authorinfo{John Bender}
           {}
           {john.m.bender@gmail.com}
\maketitle

\begin{abstract}
The jQuery JavaScript library makes the manipulation of HTML documents easy and intuitive, but an unfortunate side effect of its fluent interface is that an unwary programmer can easily introduce unnecessary performance overhead. And while the JavaScript execution in desktop browsers is become fast enough to hide much of the problem the growing complexity of HTML documents and the ubiquity of web enabled mobile devices have returned performance to a place of importance in the JavaScript development community. We address this issue using category theory to identify a set of JavaScript functions and jQuery methods that can be optimized using function composition to effect loop fusion. In addition, we propose a standard and derive a library from that standard to help developers quickly identify opportunities to make these optimizations. As a result the developers should be able to spend less time focusing on performance and more time on adding features and value to his or her applications.
\end{abstract}

\category{D.2.7}{Distribution, Maintenance, and Enhancement}{Enhancement}
\category{D.2.2}{Design Tools and Techniques}{Software libraries}

\terms
Performance, Design

\keywords
JavaScript, Category Theory, Loop Fusion, Optimization

\section{Introduction}

JavaScript that leverages the jQuery library can often be identified by its fluency. That is, users are encouraged to make alterations to jQuery objects by ``chaining'' methods [!!]. Furthermore jQuery extension authors are counciled to always return the altered jQuery object to facilitate this form of serial method invocation [!!].

\begin{figure}[h!]
\small
\begin{verbatim}
jQuery( "div" ).hide().addClass( "foo" ).show();
\end{verbatim}
\nocaptionrule \caption{Sample jQuery method chain}
\label{fig:jquery-sample}
\end{figure}

In Figure \ref{fig:jquery-sample}, all \textbf{HTMLDivElement}s in the document are retrieved using the \verb|"div"| CSS selector and used to instantiate a jQuery ``object-set''. They are then hidden, altered to add an additional CSS class, and shown again. Each method invocation, \verb|hide|, \verb|addClass|, and \verb|show| alters \textit{all} the elements in the jQuery object-set and then provides them for the next method to do the same. More concretely, if n methods of this form are invoked in sequence it will require n full iterations over the object-set.

Given that each of the methods that behave in this fashion iterates over the entirety of the jQuery object-set it's easy to see where a long sequence of them presents an opportunity for optimization by reducing the number of total iterations. Here, we hope to aid developers in reducing the number of full iterations undertaken with long method chains while otherwise maintaining the appealing fluent interface:

\begin{enumerate}
\item We define two categories \textbf{Html} and \textbf{Jqry} along with a Functor that maps from \textbf{Html} to \textbf{Jqry}. In doing so we will identify one set of JavaScript functions, the morphisms of \textbf{Html}, and their jQuery method counterparts, the morpishms of \textbf{Jqry}, that can be composed while remaining confident in the effects of their execution.
\item We define a simple standard for jQuery method and plugin developers to follow that will allow end users to manually optimize their method chains where appropriate.
\item We construct a simple and unobtrusive utility for JavaScript developers using jQuery that will alert them to possible opportunities for optimization when chaining methods that adhere to the proposed standard.
\end{enumerate}

\section{jQuery Object Method Definitions}

To facilitate the discusion it's useful to understand the two general forms that jQuery methods take when opperating on the entire set of elements. The first iterates over the jQuery object-set and relies on side effects to communicate alterations of each constituant element back into the the parent jQuery object (See Apendix for more). The second maps JavaScript functions over the \textbf{HTMLElement}s belonging to the jQuery object-set. Hereafter referred to as the map-form, this is the form we will address here. Figure \ref{fig:map-form} illustrates a simple example that uses the jQuery method \verb|map|.

\begin{figure}[h!]
\small
\begin{verbatim}
jQuery.fn.mapForm = function(){
  return this.map(function( index, htmlElement ) {
    // some alteration to the html element
    return htmlElement;
  });
};
\end{verbatim}
\nocaptionrule \caption{General map-form}
\label{fig:map-form}
\end{figure}

As with all methods defined on \verb|jQuery.fn|, \verb|this| represents an instance of the jQuery object-set. The invocation of \verb|map| on \verb|this| takes a function argument, here a closure, and passes in the index and HTMLElement of each element in the jQuery object-set. Upon successful iteration over the whole set of elements the result is returned for any subsequent method calls in a chain.

\begin{figure}[h!]
\small
\begin{verbatim}
jQuery.fn.naiveAddClass = function( cls ){
  return this.map(function( i, e ) {
    var old = e.getAttribute( "class" );
    e.setAttribute( "class", old + " " + cls );
    return e;
  });
};
\end{verbatim}
\nocaptionrule \caption{A naive reimplementation of \$.fn.addClass}
\label{fig:naive-add-class}
\end{figure}

Figure \ref{fig:naive-add-class} shows a naive reimplementation of the \verb|addClass| method using the map-form. Here \verb|cls| is the name of a new CSS class to be added to the element and \verb|e| is each HTMLElement in the jQuery object-set. As defined it can be used as a drop in replacement for the predefined version of \verb|addClass| provided by jQuery itself in \ref{fig:jquery-sample}.

\section{Html, Jqry, and a Functor}

To define \textbf{Html} and \textbf{Jqry} we must define the classes \begin{math}ob(\mathbf{Html})\end{math} of objects and \begin{math}hom(\mathbf{Html})\end{math} of morphisms for each. Then for both we must show that an identity morphism exists, composition is possible for the morphisms, that composition is associative, and finally that the set of morphisms is closed under composition [!!].

To start we define \begin{math}ob(\mathbf{Html})\end{math} as the set of the \textbf{HTMLElement} type and all its subclasses provided by a standards compliant browser's JavaScript API[!!]. We also define \begin{math}hom(\mathbf{Html})\end{math} as JavaScript functions from and to objects in \begin{math}ob(\mathbf{Html})\end{math}.

Next, we define the identity function for \textbf{Html} in the manner you would expect:

\begin{figure}[h!]
\small
\begin{verbatim}
function id( a ) {
  return a;
}
\end{verbatim}
\nocaptionrule \caption{The identity morphism in Html}
\end{figure}

The composition operation is nearly as simple, returning a new closure that, when invoked, will process the function execution in the expected order (See Apendix for sample invocation):

\begin{figure}[h!]
\small
\begin{verbatim}
function compose( f, g ){
  return function( a ) {
    return f(g(a));
  };
}
\end{verbatim}
\nocaptionrule \caption{The compose operation for Html}
\end{figure}

To show associativitly it suffices that, given different associations, the reduction remains the same, see Figure \ref{fig:html-associativity}.

\begin{figure}[h!]
\begin{displaymath}
\begin{align*}
(f\ \circ\ g \circ\ h)(x)\ &= f\ \circ\ g(h(x)) &= f(g(h(x)))\\
cmps(f,cmps(g,h))(x)\ &= cmps(f, g(h(x))) &= f(g(h(x)))\\
\end{align*}
\end{displaymath}
\begin{displaymath}
\begin{align*}
cmps(f,cmps(g,h))(x)\ &= cmps(cmps(f,g),h)(x) \\
cmps(f,g(h(x)))\ &= cmps(f(g),h(x)) \\
f(g(h(x)))\ &= f(g(h(x)))\\
\end{align*}
\end{displaymath}
\nocaptionrule \caption{Reduction of composition}
\label{fig:html-associativity}
\end{figure}

Finally we know that the morphisms in \textbf{Html} are closed under composition because the source and target objects for each morpishm both exist in \begin{math}ob(\mathbf{Html})\end{math} as \textbf{HTMLElement} or one of its subclasses.

To define \textbf{Jqry} we must demonstrate the same properties. The class \begin{math}ob(\mathbf{Jqry})\end{math} has a single object, the type of the jQuery constructor, \textbf{jQuery}. The class \begin{math}hom(\mathbf{Jqry})\end{math} is all morphisms from \textbf{jQuery} to \textbf{jQuery}. As before we first define the identity function and then the composition operation.

\begin{figure}[h!]
\small
\begin{verbatim}
jQuery.fn.identity = function() {
  return this;
}

jQuery.compose = function( f, g ){
  return function() {
    return f.call(g.call(this));
  };
}
\end{verbatim}
\nocaptionrule \caption{Identity and the compose operation for Jqry}
\end{figure}

These are distinct from their \textbf{Html} counterparts in that they ignore any parameters and rely on \verb|this| as an implicit parameter. This stems from the use of the morphisms in \textbf{Jqry} with the JavaScript dot notation which dictates the value of \verb|this| and will become important later when discussing the Functor from \textbf{Html} to \textbf{Jqry}.


\begin{figure}[h!]
\small
\begin{verbatim}
var divs = $( "div" );

assert(divs.identity() == divs);

jQuery.fn.hideIdentity =
  jQuery.compose(jQuery.fn.identity, jQuery.fn.hide);

assert(divs.hideIdentity() == divs.hide().identity());
\end{verbatim}
\nocaptionrule \caption{Example invocations of identity and compose Jqry}
\label{fig:sample-jqry-compose}
\end{figure}

Again, we take associtivity to be evident by reduction and we know that \textbf{Jqry} morphisms are closed under composition because the source and target objects are the same.

Next we define a Functor from \textbf{Html} to \textbf{Jqry} which will serve the dual purpose of exposing the proposed performance optimization and adding rigour to the definition of the morphisms in \textbf{Jqry} that can safetly be optimized. The definition consists of two parts, one that operates on the objects of \textbf{Html} and one that operates on the morpishms.

\begin{figure}[h!]
\small
\begin{verbatim}
jQuery( document.getElementById("foo") );

functor = function( morphism ){
  jQuery.map(this, morphism);
}
\end{verbatim}
\nocaptionrule \caption{Functor definition}
\end{figure}

The preservation of identity and composition is made obvious through simple illustration.

\begin{figure}[h!]
\small
\begin{verbatim}
var elem = document.getElementById( "foo" );

// preservation of identity
assert(jQuery(id(elem)) == jQuery(elem).id());

// preservation of composition
assert(functor(compose(f, g))
  == jQuery.compose(functor(f), functor(g)));
\end{verbatim}
\nocaptionrule \caption{Preserving identity and composition}
\end{figure}

Identity is trivial but composition warrants some explanation. On the left hand side the Functor promotes the already composed \textbf{Html} morphism using jQuery's \verb|map| method for operation on \verb|this|. On the right hand side each individual morphism is promoted and then \verb|jQuery.compose| performs the service of establishing \verb|this| for each execution. Most importantly the right hand side, as in Figure \ref{fig:sample-jqry-compose}, is functionally equivelant to the chaining of both methods promoted by the Functor. Given that the second Functor law holds we can say with complete confidence that two morphisms in \begin{math}hom(\mathbf{Html})\end{math} composed and then promoted into \begin{math}hom(\mathbf{Jqry})\end{math} are equivelant to the composition or chaning of two morphism in \begin{math}hom(\mathbf{Jqry})\end{math}. As a performance optimization this is generally referred to as loop fusion[!!].

\section{A Standard to Facilitate Optimization}

Given what we know about loop f

\appendix
\section{Appendix Title}

The second form, which we won't cover here but bears mentioning, is similar but substitutes \verb|each| [!!] for \verb|map|.
This is the text of the appendix, if you need one.

\begin{figure}[h!]
\small
\begin{verbatim}
function a( elem ){
  elem.setAttribute( "foo", "bar" );
  return elem;
}

function b( elem ){
  elem.setAttribute( "baz", "bak" );
  return elem;
}

var elem = document.getElementById( "anchor-tag" );
elem.getAttribute( "foo" ); // undefined
elem.getAttribute( "baz" ); // undefined

elem = compose( a, b )( elem );
elem.getAttribute( "foo" ); // "bar"
elem.getAttribute( "baz" ); // "bak"
\end{verbatim}
\nocaptionrule \caption{A sample use of composition in Html}
\end{figure}

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[loop fusion]{smith02}
\bibitem[category theory]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
