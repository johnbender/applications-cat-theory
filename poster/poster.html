<!DOCTYPE HTML>
<html>
  <head>
    <link rel="stylesheet" href="css/bootstrap.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="css/font-awesome.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="css/poster.css" type="text/css" media="screen" />
    <script type="text/javascript" src="prettify.js"></script>
  </head>
  <body onload="prettyPrint()">
    <div id="title">
      <h1>Automatically Suggesting Performance Optimizations in jQuery Based JavaScript Applications</h1>
    </div>
    <div id="content">
      <div id="left">
        <div class="row-fluid">
          <h2 class="span12">The Chains That Bind</h2>
        </div>
        <div class="row-fluid border-right">
          <div id="jquery-piechart" class="span4">
	          <div class="figure img-figure">Figure 1</div>
	          <img src="img/top-10k-bar.png" style="float: right; margin-top: 60px"/>
          </div>
          <div id="piechart-caption" class="span8 text-block">
            <h3><span class="icon-th"></span>Ubiquity Thy Name is jQuery</h3><p>jQuery is an extremely popular open source JavaScript library, dual licensed under the GPL and MIT licenses. Figure 1 shows the percentage use of jQuery among the top ten thousand, hundred thousand, and one millions websites on the internet as ranked by Alexa [!!]. Additionally the project's website sees more than one hundred thousand [!!] unique visits a month from developers all over the world. Given these numbers it's fair to say that jQuery is one of the most popular libraries available to JavaScript developers, and possibly one of the most popular open source libraries available to any developer.</p>

<p>This popularity is due in part to the fluent interface that the library promotes for manipulating the browser's document object model. As with many abstractions that simplify complex data manipulation it often requires performance tradeoffs. Here we identify a subset of chainable jQuery methods that can be fused in the interest of increasing performance. As a result we derive a simple jQuery extension that can assist developers in identifying when these methods are being used.</p>
          </div>
        </div>
        <div class="row-fluid" style="display: none">
          <div class="span12">
            <pre class="large prettyprint linenums">
jQuery( <span class="string">"div"</span> ).hide().addClass( <span class="string">"foo"</span> ).show();</pre>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="explain-chaining" class="span4 text-block">
	          <h3><span class="icon-user"></span>Fluent Interface</h3><p>In Figure 2 you can see an example of a typical DOM manipulation built using jQuery's chainable methods. In this case all the <code>HTMLDivElement</code>s are selected from the DOM, hidden, the <code>foo</code> CSS class is added, and they are shown again. Figure 3 shows a "deabstracted" naive implementation of the method chain from Figure 2, and, as you can see, iterating over the set three times where one would seemingly suffice suggests an opportunity for a performance improvement.</p>

            <p class="last">Internally these methods are implemented using for loops or in one of two forms supported by the library, the map form with <code>jQuery.map</code> and the each form with <code>jQuery.each</code>.</p>
          </div>
          <div id="for-loops" class="span8">
            <pre class="prettyprint linenums stack">jQuery( <span class="string">"div"</span> ).hide().addClass( <span class="string">"foo"</span> ).show();<div class="figure">Figure 2</div></pre>

            <pre class="prettyprint linenums">
<span class="keyword">var</span> <span class="variable-name">$divs</span> = $( <span class="string">"div"</span> );

<span class="keyword">for</span>( <span class="keyword">var</span> <span class="variable-name">i</span> = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"style"</span>, <span class="string">"display: none;"</span> );
}

<span class="keyword">for</span>( i = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"class"</span>, <span class="string">"foo"</span> );
}

<span class="keyword">for</span>( i = 0; i &lt;= length; i++ ) {
  $divs[i].setAttribute( <span class="string">"style"</span>, <span class="string">"display: block;"</span> );
}<div class="figure">Figure 3</div>
</pre>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="map-form-content" class="span6">
            <div class="text-block">
              <h3><span class="icon-share"></span>Map Form</h3>
              <p>One of the two general forms that jQuery methods take is referred to here as the "map form". This leverages the jQuery helper methods <code>jQuery.map</code> or <code>jQuery.fn.map</code> to alter each element in the jQuery object set. This is the form with which our work is predominantly concerned due to the way it promotes operations on elements without side effects.</p>
            </div>
          </div>
          <div id="each-form-content" class="span6">
            <div class="text-block">
              <h3><span class="icon-edit"></span>Each Form</h3>
              <p>The second of the two forms that one might find underlying jQuery methods is the "each form". Here side effects are the order of the day as there is no expectation that the element provided to the callback will be returned, Figure 5. The standard and optimizations described here can also be applied with this form because of JavaScript's pass by reference nature where objects are concerned. Unfortunately composition becomes impossible and the category definitions will not apply in those cases.</p>
            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div id="map-form" class="span6">
            <pre class="prettyprint linenums">
$.map( <span class="builtin">this</span>, <span class="keyword">function</span>( <span class="js2-function-param">elem</span>, <span class="js2-function-param">i</span> ){
  <span class="comment">// manipulate HTMLElement
</span>  <span class="keyword">return</span> elem;
});<div class="figure">Figure 4</div>
</pre>
          </div>
          <div id="each-form" class="span6">
            <pre class="prettyprint linenums">
$.each( <span class="builtin">this</span>, <span class="keyword">function</span>( <span class="js2-function-param">elem</span>, <span class="js2-function-param">i</span> ){
  <span class="comment">// manipulate HTMLElement
</span>});
<div class="figure">Figure 5</div>
</pre>
          </div>
        </div>
        <div class="row-fluid">
          <div class="text-block span6">
            <h3>When to Optimize?</h3>
            <p>Given that many of jQuery's core methods and the thriving plugin ecosystem that accompanies them leverage these forms [!! - possible list them in a figure] there is likely great value in identifying ways to reduce the full number of set iterations made when they are used in chains. Unfortunately the source that makes up these methods is often complex even from the implementors perspective so a rigorous definition of which can be targetted for optimization has value. For that purpose we turn to some rudimentary category theory.</p>
          </div>
          <div class="text-block span6">
            <h3>jQuery Iterative Methods</h3> TODO show some percentage of the jQuery api that is iterative. Pie chart?
          </div>
        </div>
      </div>
      <div id="middle">
        <div class="row-fluid">
          <h2 class="span12">Categorically Identifiable</h2>
        </div>
        <div class="border-right">
        <div class="row-fluid stack">
          <div id="html" class="span6 text-block">
            <img src="img/html5-logo-512.png" id="html-logo"></img>
            <h3><span class="icon-check"></span>Defining Html</h3>
            <p>The Category <strong>Html</strong> is extremely simple. The objects in <strong>Html</strong> are the HTMLElements that the reader may be familiar with from the JavaScript DOM API (eg, HTMLDivElement). The morphisms are JavaScript functions from HTMLElements to to HTMLElements. Next we verify that <strong>Html</strong> satisfies the three category laws: identity, composition, and closure under composition (Figures 6,7,8).</p>

          </div>
          <div id="jqry" class="span6 text-block">
            <img src="img/jquery-logo-320.png" id="jqry-logo"></img>
            <h3><span class="icon-check"></span>Defining Jqry</h3>
            <p><strong>Jqry</strong> is the category of <code>jQuery</code> objects and functions from <code>jQuery</code> objects to <code>jQuery</code> objects. It's only slightly more complex than <strong>Html</strong> because we take <code>this</code> to be an implicit parameter to the JavaScript functions that are the category&#8217;s morphisms. Also, these morphisms must be defined on the <code>$.fn</code> object to guarantee the value of <code>this</code> is a <code>jQuery</code> object.</p>
          </div>
        </div>
        <div class="row-fluid stack">
          <div class="span3">
            <pre class="prettyprint linenums small">
<span class="keyword">function</span> <span class="function-name">id</span>( <span class="js2-function-param">a</span> ) {
  <span class="keyword">return</span> a;
}

<div class="figure">Figure 6</div></pre>
          </div>
          <div class="span3">
            <pre class="prettyprint linenums small">
<span class="keyword">function</span> <span class="function-name">compose</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>( <span class="js2-function-param">a</span> ) {
    <span class="keyword">return</span> f(g(a));
  };
}<div class="figure">Figure 7</div></pre>
          </div>

          <div class="span3">
            <pre class="prettyprint linenums small">
<span class="js2-external-variable">$</span>.fn.<span class="function-name">id</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>;
};

<div class="figure">Figure 9</div></pre>
          </div>
          <div class="span3">
            <pre class="prettyprint linenums small">
<span class="js2-external-variable">$</span>.<span class="function-name">compose</span> = <span class="keyword">function</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> f.apply(g.apply(<span class="builtin">this</span>))
  };
};<div class="figure">Figure 10</div></pre>
          </div>
        </div>

        <div class="row-fluid stack">
          <div class="span5 text-block">
            <p>The identity function is trivial and function composition is always associative. We know that the morphisms in <strong>Html</strong> are closed under composition because the functions accept as their only argument HTMLElements and return only HTMLElements. Having met the three requirements for a category with <strong>Html</strong> we can move on to the second, and more complex category <strong>Jqry</strong>.</p>
          </div>
          <div class="span2 maths" id="identity">
            <div>
              <div>
                <img src="img/identity.png"></img>
              </div>
            </div>
          </div>
          <div class="span5 text-block">
            <p>The value of <code>this</code>, and the constraint that the morphisms must be defined on <code>$.fn</code>, play an important role in the way that the morphisms of <strong>Jqry</strong> behave. The prototype of all jQuery objects is <code>$.fn</code>, meaning when you call <code>$("div").foo()</code> it finds <code>foo</code> on the <code>$.fn</code> by following the prototype chain.</p>
          </div>
        </div>

        <div class="row-fluid stack">
          <div class="span6">
            <pre class="prettyprint linenums">
<span class="keyword">function</span> <span class="function-name">a</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"foo"</span>, <span class="string">"bar"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">function</span> <span class="function-name">b</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"baz"</span>, <span class="string">"bak"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">var</span> <span class="variable-name">elem</span> = document.getElementById( <span class="string">"sample"</span> );
elem = compose( a, b )( elem );
elem.getAttribute( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span>elem.getAttribute( <span class="string">"baz"</span> ); <span class="comment">// "bak"</span><div class="figure">Figure 8</div></pre>
          </div>
          <div class="span6">
            <pre class="prettyprint linenums">
<span class="js2-external-variable">$</span>.fn.<span class="function-name">a</span> = <span class="keyword">function</span>(){
  <span class="comment">// a from Figure 8</span>
  <span class="keyword">return</span> $.map( <span class="builtin">this</span>, a );
};

<span class="js2-external-variable">$</span>.fn.<span class="function-name">b</span> = <span class="keyword">function</span>(){
  <span class="comment">// b from Figure 8</span>
  <span class="keyword">return</span> $.map( <span class="builtin">this</span>, b );
};

<span class="keyword">var</span> <span class="variable-name">$elem</span> = $( <span class="string">"#sample"</span> );
</span><span class="js2-external-variable">$</span>.fn.aAndB = $.compose( $.fn.a, $.fn.b );
$elem.aAndB().attr( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span>$elem.attr( <span class="string">"baz"</span> );         <span class="comment">// "bak"</span><div class="figure">Figure 11</div></pre>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span5 text-block">
            <p>Notice the use of <code>a</code> and <code>b</code> from the <strong>Html</strong> <code>compose</code> example in Figure 8 for the functions that are mapped using <code>$.map</code> over the set of elements in the jQuery objects in Figure 11. This plays an important roll in understanding the Functor from <strong>Html</strong> to <strong>Jqry</strong>.</p>
          </div>
          <div class="span2 maths" id="closed-composition">
            <div>
              <div>
                <img src="img/closed-composition.png"></img>
              </div>
            </div>
          </div>
          <div class="span5 text-block">
            <p>Composition works by taking the first function, <code>g</code>, in Figure 10 and explicitly defining its <code>this</code> value using the <code>apply</code> method. The return value is a jQuery object which is used to define <code>this</code> in the application of <code>f</code>. As a result, we know that the morphisms of <strong>Jqry</strong> are closed under composition because each accepts and returns only jQuery objects.</p>
          </div>
        </div>
        </div>
        <div class="row-fluid border-left">
          <div id="functor" class="span5 text-block">
            <h3><span class="icon-check"></span>Defining a Functor</h3>
            <p>The benefits of providing these two categories are realized in a Functor from <b>Html</b> to <b>Jqry</b>. jQuery's constructor, nearly always aliased as <code>$</code>, transports the objects from <b>Html</b> (Figure !!) and <code>$.map</code> partially applied to <code>this</code> transports the morphisms (Figure !!). The preservation of composition in Figure !! suggests that jQuery methods using <code>$.map</code> with composed <b>Html</b> morphisms can be relied upon to behave identically to chains (compositions) of their transprted <b>Jqry</b> morphism counterparts.</p>
          </div>
          <div class="span7">
            <pre class="prettyprint linenums">
<span class="keyword">var</span> <span class="variable-name">elem</span>  = document.getElementById( <span class="string">"example"</span> ); <span class="comment">// HTMLElement
</span><span class="keyword">var</span> <span class="variable-name">$elem</span> = $( elem ); <span class="comment">/* or */</span> $( <span class="string">"#example"</span> );  <span class="comment">// jQuery
</span>
<span class="keyword">function</span> <span class="function-name">Functor</span>( <span class="js2-function-param">htmlMorphism</span> ) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">return</span> $.map( <span class="builtin">this</span>, htmlMorphism );
  };
}

<span class="comment">// Assuming a : HTMLElement &#8594; HTMLElement from Figure 8
</span>Functor(a); <span class="comment">// jQuery &#8594; jQuery
</span></pre>
          </div>
        </div>
        <div class="row-fluid border-left">
          <div id="functor-law-fusion" class="span12 text-block">
            <h3><span class="icon-random"></span>Fuse with Confidence</h3>
          </div>
        </div>
      </div>
      <div id="right">
        <div class="row-fluid">
          <h2 class="span12">Automatically <span class="label label-warning">Warning</span> the User</h2>
        </div>
			</div>

    </div>
  </body>
</html>
